[TOC]

[模型和数据库](https://docs.djangoproject.com/zh-hans/2.1/topics/db/)

## [模型](https://docs.djangoproject.com/zh-hans/2.1/topics/db/models/)

### 概念

1. 模型：模型是您的数据唯一而且准确的信息来源。它包含您正在储存的数据的重要字段和行为。一般来说，每一个模型都映射一个数据库表

   - 每个模型都是一个 Python 的类，这些类继承 [`django.db.models.Model`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/instances/#django.db.models.Model)
   - 模型类的每个属性都相当于一个数据库的字段。
   - 综上诉说，Django 给你一个自动生成访问数据库的 API；请参阅 [Making queries](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/)。

2. 模型使用须修改settings.py中的 INSTALLED_APPS ，在这个设置中添加包含你 models.py 文件的模块的名字


### 字段

1. 模型中最重要的、并且也是唯一必须的是数据库的字段定义。字段在类中定义。定义字段名时应小心避免使用与 models API</ref/models/instances>冲突的名称， 如  clean, save, or delete等.

2. [字段类型](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/)：Django内置了多种字段类型；你可以在模型字段参考<model-field-types>中看到完整列表。如果Django内置类型不能满足你的需求，你可以很轻松地编写自定义的字段类型；见：[doc:/howto/custom-model-fields](https://docs.djangoproject.com/zh-hans/2.1/howto/custom-model-fields/)。

3. 字段选项：每一种字段都需要指定一些特定的参数（参考 model field reference<model-field-types> ）

  - null：如果设置为 True ， 当该字段为空时，Django会将数据库中该字段设置为 NULL 。默认为 False
  - blank：如果设置为 True ，该字段允许为空。默认为 False 。（仅涉及表单验证方面）
  - choices：枚举类型，可以接收一个可迭代的列表或元组（取值：使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法）
  - default：默认值
  - primary_key：如果为True，将该字段设置为该模型的主键（如果模型没有主键，则会自动创建一个自增的主键：id）
  - unique：如果为True，则此字段为表唯一键
  - db_index：创建表索引

4. 备注名：第一个参数或指定verbose_name

  ```python
  first_name = models.CharField("person's first name", max_length=30)
  ```

5. ForeignKey, ManyToManyField and OneToOneField 接收的第一个参数为模型的类名，后面可以添加一个 verbose_name 参数：

  ```python
  poll = models.ForeignKey(
      Poll,
      on_delete=models.CASCADE,
      verbose_name="the related poll",
  )
  sites = models.ManyToManyField(Site, verbose_name="list of sites")
  place = models.OneToOneField(
      Place,
      on_delete=models.CASCADE,
      verbose_name="related place",
  )
  ```

### 关联关系

1. Django 提供了定义三种最常见的数据库关联关系的方法：多对一，多对多，一对一

2. 多对一（Many-to-one relationships）:定义一个多对一的关联关系，使用 [`django.db.models.ForeignKey`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/#django.db.models.ForeignKey) 类。就和其他 [`Field`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/#django.db.models.Field) 字段类型一样，只需要在你模型中添加一个值为该类的属性

3. 多对多（Many-to-many relationships）：定义一个多对多的关联关系，使用 [`django.db.models.ManyToManyField`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/#django.db.models.ManyToManyField) 类。就和其他 [`Field`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/#django.db.models.Field) 字段类型一样，只需要在你模型中添加一个值为该类的属性

   - 建议设置 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/#django.db.models.ManyToManyField) 字段（上例中的 `toppings` ）名为一个复数名词，表示所要光联的模型对象的集合

   - 对于多对多光联关系的两个模型，可以在任何一个模型中添加 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/#django.db.models.ManyToManyField) 字段，但**只能选择一个模型设置该字段**，即不能同时在两模型中添加该字段

   - 通常，ManyToManyField实例应该放在要在表单上编辑的对象中（比如用户参与协会关系，应定义在用户表，方便编辑用户时指定参与的协会）

   - DEMO：模型定义

     ```python
     # 定义两张表：polls_group、polls_person，并自动创建关联表：polls_person_groups
     # 1. 关联表只有person_id、group_id两个对应关系
     # 2. 在保存模型的时候，需要先保存person、group，才可以保存对应表
     from django.db import models
     
     
     class Group(models.Model):
         name = models.CharField(max_length=128)
     
         def __str__(self):
             return self.name
     
     
     class Person(models.Model):
         name = models.CharField(max_length=128)
         groups = models.ManyToManyField(Group)
     
         def __str__(self):
             return self.name
     ```

   - DEMO：模型使用

     ```shell
     from polls.models import *
     
     p1 = Person()
     p1.name = "benero"
     
     g1 = Group()
     g1.name = "g1"
     
     g2 = Group()
     g2.name = "g1"
     
     p1.groups.add(g1, g2)
     # 报错：ValueError: "<Person: benero>" needs to have a value for field "id" before this many-to-many relationship can be used.
         
     p1.save()
     p1.groups.add(g1, g2)
     # 报错：ValueError: Cannot add "<Group: g1>": instance is on database "default", value is on database "None"
     
     g1.save()
     g2.save()
     p1.groups.add(g1, g2)
     p1.save()
     
     
     ```


4. 在多对多关系中，如果关系表需要有额外的字段（如：加入协会的时间等），则可以手动创建关联表，并在models使用through进行关联，通过这种方式创建的模型，不能使用`add()`, `create()`, or `set()` 创建关系

   - DEMO：模型

     ```python
     # 定义三张表：person、group及关联表：membership
     
     from django.db import models
     
     
     class Group(models.Model):
         name = models.CharField(max_length=128)
     
         def __str__(self):
             return self.name
     
     
     class Person(models.Model):
         name = models.CharField(max_length=128)
         groups = models.ManyToManyField(Group, through="Membership")
     
         def __str__(self):
             return self.name
     
     
     class Membership(models.Model):
         person = models.ForeignKey(Person, on_delete=models.CASCADE)
         group = models.ForeignKey(Group, on_delete=models.CASCADE)
         date_joined = models.DateField()
         invite_reason = models.CharField(max_length=64)
     
     
     ```

   - DEMO：模型使用

     ```python
     from datetime import date
     
     from polls.models import *
     
     
     p1 = Person.objects.create(name="p1")
     p2 = Person.objects.create(name="p2")
     p3 = Person.objects.create(name="p3")
     
     g1 = Group.objects.create(name="g1")
     g2 = Group.objects.create(name="g2")
     
     # 手动创建关联关系
     m1 = Membership(person=p1, group=g1, date_joined=date(2018, 1, 1), invite_reason="hi")
     m1.save()
     
     m2 = Membership(person=p1, group=g2, date_joined=date(2018, 1, 1), invite_reason="hi")
     m2.save()
     
     # 查看person加入的group
     p1.groups.all()
     <QuerySet [<Group: g1>, <Group: g2>]>
     
     # 有两个方式获取关联关系的表数据
     # 1. 直接通过Membership模型
     p1_membership = Membership.objects.get(person=p1, group=g1)
     
     # 2. 通过Person/Group模型
     p1_membership = p1.membership_set.get(group=g1)
     ```

5. 一对一（One-to-one relationships）：要定义一对一关系，请使用OneToOneField，一般用于某个表的扩展表

   - DEMO：模型定义

     ```python
     from django.db import models
     
     
     class Group(models.Model):
         name = models.CharField(max_length=128)
     
         def __str__(self):
             return self.name
     
     
     class Person(models.Model):
         name = models.CharField(max_length=128)
         groups = models.ManyToManyField(Group, through="Membership")
     
         def __str__(self):
             return self.name
     
     
     class Membership(models.Model):
         person = models.ForeignKey(Person, on_delete=models.CASCADE)
         group = models.ForeignKey(Group, on_delete=models.CASCADE)
         date_joined = models.DateField()
         invite_reason = models.CharField(max_length=64)
     
     
     class PersonGroupExt(models.Model):
         """
         @summary: 用户在group的扩展信息表
         """
         person = models.OneToOneField(Person, on_delete=models.CASCADE, primary_key=True)
         first_group = models.ForeignKey(Group, null=True, on_delete=models.SET_NULL)
         remark = models.CharField(max_length=100, null=True)
     
     
     
     ```

   - DEMO模型使用

     ```python
     from polls.models import *
     
     
     p1 = Person.objects.get(name="p1")
     p2 = Person.objects.get(name="p2")
     g1 = Group.objects.get(name="g1")
     g2 = Group.objects.get(name="g2")
     
     p1_ext = PersonGroupExt(person=p1, first_group=g1, remark="hello")
     p1_ext.save()
     
     p2_ext = PersonGroupExt(person=p2, first_group=g2, remark="hello")
     p2_ext.save()
     
     # g2删掉后，p2_ext的first_group自动设为NULL(on_delete=models.SET_NULL)
     g2.delete()
     type(p2_ext.first_group)
     # <class 'NoneType'>
     
     # 当p2删除后，对应的membership、p2_ext自动删除(on_delete=models.CASCADE)
     p2.delete()
     
     ```



### [Meta options 元选项](https://docs.djangoproject.com/zh-hans/2.1/ref/models/options/)：可选

1. Model metadata is "anything that's not a field", such as ordering options ([`ordering`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/options/#django.db.models.Options.ordering)), database table name ([`db_table`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/options/#django.db.models.Options.db_table)), or human-readable singular and plural names ([`verbose_name`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/options/#django.db.models.Options.verbose_name) and [`verbose_name_plural`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/options/#django.db.models.Options.verbose_name_plural)). None are required, and adding `class Meta` to a model is completely optional.

2. 用法

   ```python
   from django.db import models
   
   class Ox(models.Model):
       horn_length = models.IntegerField()
   
       class Meta:
           ordering = ["horn_length"]
           verbose_name_plural = "oxen"
   ```

3. Available Meta options

   - abstract：If `abstract = True`, this model will be an [**abstract base class**](https://docs.djangoproject.com/zh-hans/2.1/topics/db/models/#abstract-base-classes).

   - app_label：If a model is defined outside of an application in [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-INSTALLED_APPS), it must be declared

   - db_table：The name of the database table to use for the model

   - managed：If True，由Django管理数据库表的生命周期

   - ordering：The default ordering for the object, for use when obtaining lists of objects

   - permissions：Extra permissions to enter into the permissions table when creating this object

   - default_permissions：Defaults to `('add', 'change', 'delete', 'view')`

   - proxy：If proxy = True, a model which subclasses another model will be treated as **a proxy model.**

   - indexes：A list of [indexes](https://docs.djangoproject.com/zh-hans/2.1/ref/models/indexes/) that you want to define on the model

     ```python
     from django.db import models
     
     class Customer(models.Model):
         first_name = models.CharField(max_length=100)
         last_name = models.CharField(max_length=100)
     
         class Meta:
             indexes = [
                 models.Index(fields=['last_name', 'first_name']),
                 models.Index(fields=['first_name'], name='first_name_idx'),
             ]
     ```

   - unique_together：Sets of field names that, taken together, must be unique: ManyToManyField不能包含在unique_together中

     ```python
     unique_together = (("driver", "restaurant"),)
     ```

   - verbose_name：A human-readable name for the object, singular

   - verbose_name_plural：The plural name for the object



### Model attributes

**objects**

The most important attribute of a model is the **Manager**. It's the interface through which database query operations are provided to Django models and is used to retrieve the instances from the database. If no custom Manager is defined, the default name is objects. **Managers are only accessible via model classes, not the model instances.**



### Model methods

1. 在模型上定义自定义方法，以向对象添加自定义“行级”功能。虽然Manager方法旨在执行“表格范围”的事情，但模型方法应该作用于特定的模型实例。

2. Fat model， thin view：逻辑代码和业务代码解耦分离，功能性函数以及对数据库的操作定义写在models里面，业务逻辑写在view里面

3. 可以在Model中覆盖预定义的模型方法，并通过super().save(*args, **kwargs)操作DB

4. 注意：批量删除或通过关联删除不会调用delete()方法，但可以使用pre_delete()、post_delete()触发；而批量创建或更新时目前没有方法，因为不会调用save()、pre_save()、post_save()

   ```python
   from django.db import models
   
   class Person(models.Model):
       first_name = models.CharField(max_length=50)
       last_name = models.CharField(max_length=50)
       birth_date = models.DateField()
   
       def baby_boomer_status(self):
           "Returns the person's baby-boomer status."
           import datetime
           if self.birth_date < datetime.date(1945, 8, 1):
               return "Pre-boomer"
           elif self.birth_date < datetime.date(1965, 1, 1):
               return "Baby boomer"
           else:
               return "Post-boomer"
   
       @property
       def full_name(self):
           "Returns the person's full name."
           return '%s %s' % (self.first_name, self.last_name)
       
       def save(self, *args, **kwargs):
           do_something()
           super().save(*args, **kwargs)  # Call the "real" save() method.
           do_something_else()
   ```

5. Executing custom SQL：另一种常见模式是在模型方法和模块级方法中编写自定义SQL语句 [row SQL](https://docs.djangoproject.com/zh-hans/2.1/topics/db/sql/)



## 【TODO】模型继承





### Organizing models in a package

1. manage.py startapp命令创建一个包含models.py文件的应用程序结构。如果您有许多模型，则可能需要创建一个models package

2. 删除models.py并使用``__init__.py``文件和用于存储模型的文件创建myapp / models /目录。您必须在``__init__.py``文件中导入模型

   ```python
   from .organic import Person
   from .synthetic import Robot
   ```

3. 显式导入每个模型而不是使用.models import *具有不会使命名空间混乱，使代码更具可读性以及保持代码分析工具有用的优点。



### migrate

1. 一般操作：修改models.py > 生成迁移文件 > 执行迁移脚本

```shell
# 生成迁移文件
python manage.py makemigrations polls

# 查看迁移文件实际生成的SQL
python manage.py sqlmigrate polls 0001

# 执行迁移
python manage.py migrate

# 查看迁移情况
python manage.py showmigrations polls

```

2. 最后一步的迁移有误，怎么回退并重新生成迁移文件

```shell
# 指定要回退的版本，并进行迁移(回退所有版本，则直接指定为zero)：执行后将删除DB对应的改变
python manage.py migrate polls zero

# 删除迁移文件 > 修改models.py > 重新生成迁移文件 > 执行迁移脚本
...

```

3. 跳过建表操作的迁移（DB中已有对应的表并且不能删除）

```shell
# Allows Django to skip an app’s initial migration if all database tables with the names of all models created by all CreateModel operations in that migration already exist. This option is intended for use when first running migrations against a database that preexisted the use of migrations. This option does not, however, check for matching database schema beyond matching table names and so is only safe to use if you are confident that your existing schema matches what is recorded in your initial migration.

python manage.py migrate --fake-initial
```

4. 如果DB已有对应的改动，但迁移记录没有对应的记录

```shell
# Marks the migrations up to the target one (following the rules above) as applied, but without actually running the SQL to change your database schema.

# This is intended for advanced users to manipulate the current migration state directly if they’re manually applying changes; be warned that using --fake runs the risk of putting the migration state table into a state where manual recovery will be needed to make migrations run correctly.

python manage migrate polls --fake
```





## [Making queries](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/)

1. 一旦你创建了数据模型，Django就会自动为你提供一个数据库抽象API，让你可以创建，检索，更新和删除对象。本文档介绍了如何使用此API。有关所有各种模型查找选项的完整详细信息，请参阅[数据模型参考](https://docs.djangoproject.com/zh-hans/2.1/ref/models/)

2. [如何查看Django生成的SQL](https://docs.djangoproject.com/en/2.1/faq/models/#how-can-i-see-the-raw-sql-queries-django-is-running)：Django的DEBUG需要设置为True

   ```python
   # Make sure your Django DEBUG setting is set to True. Then, just do this:
   from django.db import connection
   connection.queries
   
   # 多个DB可以使用connections
   from django.db import connections
   connections['my_db_alias'].queries
   
   # 重设queries
   from django.db import reset_queries
   reset_queries()
   
   # 直接使用query(extra使用别名)
   Tag.objects.all().extra(select={'tag_name': 'name'}).query.__str__()
   Out[47]: u'SELECT (name) AS "tag_name", "blog_tag"."id", "blog_tag"."name" FROM "blog_tag"'
   ```

3. [如何在Django调试时输出SQL](https://blog.csdn.net/pushiqiang/article/details/79571169)

   ```python
   # 在settings.py里,配置如下logging
   LOGGING = {
       'version': 1,
       'disable_existing_loggers': False,
       'handlers': {
           'console':{
               'level':'DEBUG',
               'class':'logging.StreamHandler',
           },
       },
       'loggers': {
           'django.db.backends': {
               'handlers': ['console'],
               'propagate': True,
               'level':'DEBUG',
           },
       }
   }
   ```

4. 



### [Creating objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#creating-objects)

1. 为了在Python对象中表示数据库表数据，Django使用此直接的方式：模型类表示数据库表，该类的实例表示数据库表中的特定记录

2. To create an object, instantiate it using keyword arguments to the model class, then call [`save()`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/instances/#django.db.models.Model.save) to save it to the database（只有显式调用save方法才会执行INSERT语句）

3. [DEMO](https://www.kancloud.cn/hiyang/py/348225)

   ```python
   # 方法1 
   models.Person.objects.create(name=name,age=age)
   
   # 方法2
   # 防止重复的最好方法 返回值(object, True/False)
   # 第一个为Person对象，第二个为True或False, 新建时返回的是True, 已经存在时返回False
   # 重复与否的判断不包括自增列
   Person.objects.get_or_create(name=name,age=age)
   
   # 方法3 
   p = models.Person(name=name,age=age)
   p.save()
   
   p = models.Person(name="TWZ")
   p.age = 23
   p.save()
   
   # 方法4
   dic = {name: name, age: age}
   models.Person.objects.create(**dic)
   ```


### [Saving changes to objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#saving-changes-to-objects)

1. 单个 object 更新，适合于 .get(), get_or_create(), update_or_create() 等得到的 obj，和新建很类似

   ```python
   twz = Author.objects.get(name="WeizhongTu")
   twz.name="WeizhongTu"
   twz.email="tuweizhong@163.com"
   twz.save()
   ```

2. 批量更新，适用于 .all() .filter() .exclude() 等后面 (危险操作，正式场合操作务必谨慎)

   ```python
   # 先获取实例，再进行更新
   Person.objects.filter(name=name).update(name=newname)
   ```

3. get()取到的对象不能update，filter()可以。因为filter返回QuerySet对象，而get()直接返回model实例

   ```shell
   Person.objects
   <django.db.models.manager.Manager object at 0x1040c0f28>
   
   Person.objects.filter(name="p1")
   <QuerySet [<Person: p1>]>
   
   Person.objects.filter(name="p1").get()
   <Person: p1>
   ```


### [Retrieving objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#retrieving-objects)

1. To retrieve objects from your database, construct a [`QuerySet`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/querysets/#django.db.models.query.QuerySet) via a [`Manager`](https://docs.djangoproject.com/zh-hans/2.1/topics/db/managers/#django.db.models.Manager) on your model class.

2. A [`QuerySet`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/querysets/#django.db.models.query.QuerySet) represents a collection of objects from your database. It can have zero, one or many *filters*. Filters narrow down the query results based on the given parameters. In SQL terms, a [`QuerySet`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/querysets/#django.db.models.query.QuerySet) equates to a `SELECT` statement, and a filter is a limiting clause such as `WHERE` or `LIMIT`.

3. You get a [`QuerySet`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/querysets/#django.db.models.query.QuerySet) by using your model's [`Manager`](https://docs.djangoproject.com/zh-hans/2.1/topics/db/managers/#django.db.models.Manager). Each model has at least one [`Manager`](https://docs.djangoproject.com/zh-hans/2.1/topics/db/managers/#django.db.models.Manager), and it's called [`objects`](https://docs.djangoproject.com/zh-hans/2.1/ref/models/class/#django.db.models.Model.objects) by default. 

4. `Managers` are accessible only via model classes, rather than from model instances, to enforce a separation between "table-level" operations and "record-level" operations.

5. [DEMO](https://www.kancloud.cn/hiyang/py/348225)

   ```python
   # 获取所有内容，返回值为记录的对象
   models.Person.objects.all()
   # 切片操作，获取10个人，不支持负索引，切片可以节约内存(相当于LIMIT)
   Person.objects.all()[:10] 
   
   # 获取一条记录，未取到会报错，超过两条也会报错(直接返回一个Person的实例)
   Person.objects.get(name=name)
   
   # 获取多条记录
   ## name严格等于 "abc" 的人
   Person.objects.filter(name__exact="abc") 
   Person.objects.filter(name="abc") 
   
   # 名称为 abc 但是不区分大小写，可以找到 ABC, Abc, aBC
   Person.objects.filter(name__iexact="abc") 
   
   # 名称中包含 "abc"的人
   Person.objects.filter(name__contains="abc") 
   #名称中包含 "abc"，且abc不区分大小写
   Person.objects.filter(name__icontains="abc") 
   
   # 正则表达式查询
   Person.objects.filter(name__regex="^abc") 
   # 正则表达式不区分大小写
   Person.objects.filter(name__iregex="^abc")
   
   # 排除包含 WZ 的Person对象
   Person.objects.exclude(name__contains="WZ") 
   
   # 找出名称含有abc, 但是排除年龄是23岁的
   Person.objects.filter(name__contains="abc").exclude(age=23) 
   
   icontains(大小写无关的LIKE)contains
   startswith istartswith和endswith iendswith 
   range in	# 范围
   gt lt gte lte 	# 比较操作 
   isnull		# 允许为空
   ```

6. The lookup parameters (`**kwargs` in the above function definitions) should be in the format described in [Field lookups](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#field-lookups) below. （如：demo中的name**__contains**）

7. Lookups that span relationships（跨表查询）

   ```python
   # 此示例检索所有具有至少一个标题包含“Lennon”的条目的Blog对象：
   Entry.objects.filter(blog__name='Beatles Blog')
   
   # 此示例检索所有具有至少一个标题包含“Lennon”的条目的Blog对象
   Blog.objects.filter(entry__headline__contains='Lennon')
   
   
   ```

8. Filters can reference fields on the model：比较同一模型实例上两个不同字段的值

   ```python
   # 要查找条目评级小于pingback计数和评论计数总和的所有条目，我们将发出查询：
   Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))
   ```

9. 【TODO】[Caching and QuerySets](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#caching-and-querysets)：


### [Complex lookups with `Q` objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#complex-lookups-with-q-objects)



### [Comparing objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#comparing-objects)



### [Deleting objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#deleting-objects)



### [Copying model instances](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#copying-model-instances)



### [Updating multiple objects at once](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#updating-multiple-objects-at-once)



### [Related objects](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#related-objects)





### [Falling back to raw SQL](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/#falling-back-to-raw-sql)